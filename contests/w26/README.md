
### 26주차 경연대회 Result

* 613/ 6951 participants : in 9% (= 8.8 %)

This time I was little bit improved ..but far way to go..


```
4% will get the gold medal
12% will get the silver medal
25% will get the broze medal
```

### 26주차 경연대회를 마치고 동욱이에게 보낸 메일

구종만씨가 쓴 책을 캘거리 있는 직장 후배가 추천한 적이 있었는데... 우리나라도 좋은 책들을 쓰는 사람들이 있군.. 다행이라는 생각이 들어..^^

아래의 서문을 읽고 나서 좋은 책이라는 확신을 가졌어..

문득 체계적으로 공부한다는 말을 듣고 생각이 든 것이..너무 처음부터 ABC 식으로 공부하려고 하는 것보다..
마치 아이들이 오락 게임을 하듯이 한 달에 한 두번.. 정기적으로 좋은 문제들을 공유해서 풀어보고 서로 이야기를 하는 것이 실제로 많이 늘겠다는 생각이 들더라고..

나는 hackerrank에 있는 러시아 사람과 북미에 있는 2-3명.. 그리고 한국에 있는 사람 3명 정도와 그 동안 대회를 4 번 참가하면서 대화를 했는데.. 대화를 하면서 느낀 것이... 많지.. 대부분의 사람들은 비슷하다..
나 같이 조금 더...잘 하고 싶어하는 사람은 같이 할 사람들을 찾고 있었고..(잘 하는 사람들도 포함해서..) 모든 어려운 문제들을 푸는 사람들은 다 같이 힘들어한다는 것을 느꼈어..

지난 일요일에는 아주 극단적인 난이도의 문제를 접하고 나는 15시간 가량 고민하다가 부분 점수만 받고 포기했지..
그런데 항상 Top 10 랭크 안에 들어가는 한 러시아 인에게 물어보니 자기도 마지막 20분 전까지 하루 온종일 풀었다고 하더라고..나중에 문제를 해킹해서 다운 받아보았지.. 경악했어.. (문제를 이해할 필요는 없지만.. 한번 소스를 열어보기를 ..)

그리고 우연히 한 독일인이 푼 파이손 소스를 보았는데.. 두 개의 만점을 받은 소스가 완전히 극과 극의 그림을 보여준거야..
한번 대충 보면 너도 많은 생각을 하게 할 거야.. 둘 다 모두 만점을 받은 프로그램이야.. 극단적으로 많은 데이타의 테스트 케이스도 모두 통과하고..

아뭏든 이 일을 계속할 것인가 라는 생각과 함께..계속 할 것이면 조금 씩.. 노력을 하자..하는 결론을 도달했지..

![bible1](https://cloud.githubusercontent.com/assets/5623445/20942877/53135da4-bbcb-11e6-9979-45d36c4c9342.PNG)
![bible2](https://cloud.githubusercontent.com/assets/5623445/20942878/531c4d6a-bbcb-11e6-8dc4-dee914bef0d8.PNG)

### Mail from @bluedawnstar

이 사이트에서 활동하고 있는 몇 몇 분들은 대부분 회사 동료였거나 건너건너 알게된 사람들인데,
최근에 한국에서도 알고리즘 공부를 위한 많은 모임들이 생겨나고 있어요.
젠 오랫동알 개발을 해왔지만 coding contest가 운영되고 있다는 사실을 3년전에야 할 정도로 이런 문화와는 담쌓고 살았던 사람입니다.
뒤늦게 알게된 후 쭉 공부를 해오고 있지만 아직 갈길이 멀게만 느껴집니다.
HackerRank는 올해 알게되어 활동을 시작했는데, Week of Code 같은 경우는 다른 contest와는 문제는 어렵지만 시간을 충분히 주기때문에
저와 잘 맞다는 느낌이 들고 그래서 그런지 다른 대회보다는 성적이 잘 나오는 것 같네요.

알고리즘관련 coding contest는 많이 있지만 체계적으로 공부할 수 있는 방법이 마땅치않은 것도 사실입니다.
한국에 계신다면 많은 컴뮤니티를 통해서 좋은 활동 많이 하시면서 실력을 키우실 수 있곘지만 그렇시지 못하니 혼자 할 수 있는 방법들을 말씀드릴게요.

1) https://leetcode.com/
이미 아시고 계시지는 않을까 생각합니다만, 이 사이트는 문제를 푸는 사이트이기는 하지만 문제들이 기술 인터뷰에
나왔거나 나올만한 문제들을 다루고 있습니다.
체계적으로 공부할 수 있게 해주고 실제 인터뷰 준비도 겸할 수 있기 때문에 Google 등 기술 면접을 준비하는 사람들에게 굉장히 인기있는 사이트입니다.
Coding contest에만 참가하다보면 체계적으로 공부하는게 아니라는 생각이 들게되는데 이 사이트는 체계가 잡혀있어서 매우 좋습니다. 강추합니다.

2) https://algospot.com
구종만님이라는 한국인 중에서는 알아주는 분이 만든 사이트입니다.
이 사이트는 정말 한국인 초고수들도 많이 포진되어있는 community이자 문제풀이 사이트입니다.
캐나다에서도 구하실 수 있을지 모르겠지만 아래 사이트에 있는 책과 같이 보시면 아주 좋습니다.

3) 책 "알고리즘 문제 해결 전략"
이 책은 위에서 말씀드린 구종만 님이 집필하신 책인데, 이 두번은 한국에서 coding contest에 참가하시는 분들에게는 bible입니다.
이 책 내용만 제대로 이해해도 굉장한 실력자가 되실 수 있습니다.
다른 책 필요 없습니다. 이 책이면 끝입니다.

http://www.yes24.com/24/goods/8006522?scode=032

4) 책 "Introduction to Algorithms"
이 책에도 주옥같은 내용들이 많이 있어요. 이 책도 algorithm 공부하시는 분들에게는 bible 중 하나입니다.
Coding contest를 대비하고자 쓰여진 책은 아니니 필요할 때 참고하시면 좋겠습니다.

http://www.yes24.com/searchcorner/Search?keywordAd=&keyword=&domain=BOOK&qdomain=%B1%B9%B3%BB%B5%B5%BC%AD&query=Introduction+to+algorithms

5) 그외
기본적인 algorithm 공부도 하시면서 문제도 많이 필어보는 것이 가장 중요하구요.
무엇보다도 공부한 내용을 자신에 맞게 어딘가에다 정리해 놓으시고,
또 코드들을 잘 정리해서 자신만의 library를 구축하고 코딩 대회에서 언제든지 꺼내 쓸 수 있도록 평소에 준비를 해두셔야 합니다.
코드 구하기 어려우실 때는 아래 사이트를 이용해보세요. 어지간한 코드는 다 구하실 수 있습니다.

http://www.geeksforgeeks.org/

### Something to read

https://iamprogrammer.io/2015/11/09/episode-16-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8A%B9%EC%A7%91-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5%EC%9D%98-%EA%B5%AC%EC%A2%85%EB%A7%8C/

http://www.venturesquare.net/531197

http://www.slideshare.net/skoopmedia/10-39955766

### Interesting comparision

어느 누구도 .. 아래의 두 개의 프로그램을 처음 훝어보고나서.. 이 두 개의 논리가 동일한 목적을 완벽하게 수행하는 프로그램이라고 믿을 수는 없다..

Below are the different solutions on the same question of the Day7.. both get 100% score

```cpp
#pragma GCC diagnostic ignored "-Wunused-result"

#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cassert>

const int MOD = 1000 * 1000 * 1000 + 7;

inline int modAdd(int a, int b) {
	return (a + b) % MOD;
}

inline int modAdd(int a, int b, int c) {
	return modAdd(modAdd(a, b), c);
}

inline int modSub(int a, int b) {
	return (a - b + MOD) % MOD;
}

inline void modInc(int &a) {
	a++;
	if (a == MOD) {
		a = 0;
	}
}

inline int modMul(int a, int b) {
	return int((1LL * a * b) % MOD);
}

inline int modMul(int a, int b, int c) {
	return modMul(modMul(a, b), c);
}

inline int modMul(int a, int b, int c, int d) {
	return modMul(modMul(a, b), modMul(c, d));
}

int modPow(int a, int n) {
	int res = 1;
	while (n > 0) {
		if ((n & 1) != 0) {
			res = modMul(res, a);
			n--;
		} else {
			a = modMul(a, a);
			n >>= 1;
		}
	}
	return res;
}

int modRev(int a) {
	return modPow(a, MOD - 2);
}

int modDiv(int a, int b) {
	return modMul(a, modRev(b));
}

int found[100][100]; // [n][m] -> res, -1 is not filled

int solveSlowest(int n, int m) {
	int count = 0;
	if (n == 1) {
		assert(1 <= m && m <= 62);
		for (long long v1 = 1; v1 < 1LL << m; v1++) {
			modInc(count);
		}
	} else if (n == 2) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v1 != v2 && (v1 ^ v2) != 0) {
					modInc(count);
				}
			}
		}
	} else if (n == 3) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					if (v1 != v2 && v1 != v3 && v2 != v3 && (v1 ^ v2 ^ v3) != 0) {
						modInc(count);
					}
				}
			}
		}
	} else if (n == 4) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						if (v1 != v2 && v1 != v3 && v1 != v4 && v2 != v3 && v2 != v4 && v3 != v4 && (v1 ^ v2 ^ v3 ^ v4) != 0) {
							modInc(count);
						}
					}
				}
			}
		}
	} else if (n == 5) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						for (int v5 = 1; v5 < 1 << m; v5++) {
							if (v1 != v2 && v1 != v3 && v1 != v4 && v1 != v5 && v2 != v3 && v2 != v4 && v2 != v5 && v3 != v4 && v3 != v5 && v4 != v5 && (v1 ^ v2 ^ v3 ^ v4 ^ v5) != 0) {
								modInc(count);
							}
						}
					}
				}
			}
		}
	} else if (n == 6) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						for (int v5 = 1; v5 < 1 << m; v5++) {
							for (int v6 = 1; v6 < 1 << m; v6++) {
								if (
									v1 != v2 && v1 != v3 && v1 != v4 && v1 != v5 && v1 != v6 &&
									v2 != v3 && v2 != v4 && v2 != v5 && v2 != v6 &&
									v3 != v4 && v3 != v5 && v3 != v6 &&
									v4 != v5 && v4 != v6 &&
									v5 != v6 &&
									(v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6) != 0
								) {
									modInc(count);
								}
							}
						}
					}
				}
			}
		}
	} else if (n == 7) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						for (int v5 = 1; v5 < 1 << m; v5++) {
							for (int v6 = 1; v6 < 1 << m; v6++) {
								for (int v7 = 1; v7 < 1 << m; v7++) {
									if (
										v1 != v2 && v1 != v3 && v1 != v4 && v1 != v5 && v1 != v6 && v1 != v7 &&
										v2 != v3 && v2 != v4 && v2 != v5 && v2 != v6 && v2 != v7 &&
										v3 != v4 && v3 != v5 && v3 != v6 && v3 != v7 &&
										v4 != v5 && v4 != v6 && v4 != v7 &&
										v5 != v6 && v5 != v7 &&
										v6 != v7 &&
										(v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7) != 0
									) {
										modInc(count);
									}
								}
							}
						}
					}
				}
			}
		}
	} else if (n == 8) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						for (int v5 = 1; v5 < 1 << m; v5++) {
							for (int v6 = 1; v6 < 1 << m; v6++) {
								for (int v7 = 1; v7 < 1 << m; v7++) {
									for (int v8 = 1; v8 < 1 << m; v8++) {
										if (
											v1 != v2 && v1 != v3 && v1 != v4 && v1 != v5 && v1 != v6 && v1 != v7 && v1 != v8 &&
											v2 != v3 && v2 != v4 && v2 != v5 && v2 != v6 && v2 != v7 && v2 != v8 &&
											v3 != v4 && v3 != v5 && v3 != v6 && v3 != v7 && v3 != v8 &&
											v4 != v5 && v4 != v6 && v4 != v7 && v4 != v8 &&
											v5 != v6 && v5 != v7 && v5 != v8 &&
											v6 != v7 && v6 != v8 &&
											v7 != v8 &&
											(v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 ^ v8) != 0
										) {
											modInc(count);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	} else if (n == 9) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				for (int v3 = 1; v3 < 1 << m; v3++) {
					for (int v4 = 1; v4 < 1 << m; v4++) {
						for (int v5 = 1; v5 < 1 << m; v5++) {
							for (int v6 = 1; v6 < 1 << m; v6++) {
								for (int v7 = 1; v7 < 1 << m; v7++) {
									for (int v8 = 1; v8 < 1 << m; v8++) {
										for (int v9 = 1; v9 < 1 << m; v9++) {
											if (
												v1 != v2 && v1 != v3 && v1 != v4 && v1 != v5 && v1 != v6 && v1 != v7 && v1 != v8 && v1 != v9 &&
												v2 != v3 && v2 != v4 && v2 != v5 && v2 != v6 && v2 != v7 && v2 != v8 && v2 != v9 &&
												v3 != v4 && v3 != v5 && v3 != v6 && v3 != v7 && v3 != v8 && v3 != v9 &&
												v4 != v5 && v4 != v6 && v4 != v7 && v4 != v8 && v4 != v9 &&
												v5 != v6 && v5 != v7 && v5 != v8 && v5 != v9 &&
												v6 != v7 && v6 != v8 && v6 != v9 &&
												v7 != v8 && v7 != v9 &&
												v8 != v9 &&
												(v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 ^ v8 ^ v9) != 0
											) {
												modInc(count);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	} else {
		assert(false);
	}
	return count;
}

int solveSlow(int n, int m) {
	if (m < 30 && n > (1 << m) - 1) {
		return 0; // the number of piles is greater than the amount of allowed numbers, return zero
	}
	int count = 0;
	if (n == 1) {
		return modSub(modPow(2, m), 1); // the number of values 1 <= x < 2^m
	} else if (n == 2) {
		int cnt1 = modSub(modPow(2, m), 1); // any number
		int cnt2 = modSub(modPow(2, m), 2); // any number except the first
		return modMul(cnt1, cnt2); // just multiply, xor == 0 mean that the numbers are equal but they are distinct
	} else if (n == 3) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					// should not be: v1 ^ v2 ^ v3 == 0
					int except = v1 ^ v2;
					if (except == v1 || except == v2) {
						count = modAdd(count, (1 << m) - 3);
						assert(false); // never happens for n == 3
					} else {
						count = modAdd(count, (1 << m) - 4);
					}
				}
			}
		}
		// printf("n=%d m=%d count=%d\n", n, m, count);
	} else if (n == 4) {
		assert(1 <= m && m <= 30);
		int lost = 0;
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							// should not be: v1 ^ v2 ^ v3 ^ v4 == 0
							int except = v1 ^ v2 ^ v3;
							if (except == v1 || except == v2 || except == v3 || except == 0) {
								count = modAdd(count, (1 << m) - 4); // only except == 0 happens for n == 4
								lost++;
							} else {
								count = modAdd(count, (1 << m) - 5);
							}
						}
					}
				}
			}
		}
		// printf("n=%d m=%d count=%d lost=%d\n", n, m, count, lost);
	} else if (n == 5) {
		assert(1 <= m && m <= 30);
		int lost = 0;
		int nEx0 = 0;
		int nExEq = 0;
		int nExNe = 0;
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							for (int v4 = 1; v4 < 1 << m; v4++) {
								if (v4 != v1 && v4 != v2 && v4 != v3) {
									// should not be: v1 ^ v2 ^ v3 ^ v4 ^ v5 == 0
									int except = v1 ^ v2 ^ v3 ^ v4;
									if (except == 0) {
										count = modAdd(count, (1 << m) - 5);
										lost++;
										nEx0++;
									} else if (except == v1 || except == v2 || except == v3 || except == v4) {
										count = modAdd(count, (1 << m) - 5);
										lost++;
										nExEq++;
									} else {
										count = modAdd(count, (1 << m) - 6);
										nExNe++;
									}
								}
							}
						}
					}
				}
			}
		}
		// printf("n=%d m=%d count=%d lost=%d\n", n, m, count, lost);
		// if (m == 3) {
		//	printf("n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", n, m, nEx0, nExEq, nExNe);
		// }
	} else if (n == 6) {
		assert(1 <= m && m <= 30);
		int nEx0 = 0;
		int nEx1 = 0;
		int nExEq = 0;
		int nExNe = 0;
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							for (int v4 = 1; v4 < 1 << m; v4++) {
								if (v4 != v1 && v4 != v2 && v4 != v3) {
									for (int v5 = 1; v5 < 1 << m; v5++) {
										if (v5 != v1 && v5 != v2 && v5 != v3 && v5 != v4) {
											// should not be: v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 == 0
											int except = v1 ^ v2 ^ v3 ^ v4 ^ v5;
											if (except == 0) {
												count = modAdd(count, (1 << m) - 6);
												nEx0++;
											} else if (except == v1) {
												if (m == 3) {
													// printf("except == v1 v1=%d v2=%d v3=%d v4=%d v5=%d\n", v1, v2, v3, v4, v5);
												}
												count = modAdd(count, (1 << m) - 6);
												assert((v2 ^ v3 ^ v4 ^ v5) == 0);
												nEx1++;
												nExEq++;
											} else if (except == v2 || except == v3 || except == v4 || except == v5) {
												count = modAdd(count, (1 << m) - 6);
												nExEq++;
											} else {
												count = modAdd(count, (1 << m) - 7);
												nExNe++;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		// if (m == 3) {
			// printf("n=%d m=%d nEx0=%d nExEq=%d nExNe=%d nEx1=%d\n", n, m, nEx0, nExEq, nExNe, nEx1);
		// }
	} else if (n == 7) {
		assert(1 <= m && m <= 30);
		int nEx0 = 0;
		int nExEq = 0;
		int nExNe = 0;
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							for (int v4 = 1; v4 < 1 << m; v4++) {
								if (v4 != v1 && v4 != v2 && v4 != v3) {
									for (int v5 = 1; v5 < 1 << m; v5++) {
										if (v5 != v1 && v5 != v2 && v5 != v3 && v5 != v4) {
											for (int v6 = 1; v6 < 1 << m; v6++) {
												if (v6 != v1 && v6 != v2 && v6 != v3 && v6 != v4 && v6 != v5) {
													// should not be: v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 == 0
													int except = v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6;
													if (except == 0) {
														count = modAdd(count, (1 << m) - 7);
														nEx0++;
													} else if (except == v1 || except == v2 || except == v3 || except == v4 || except == v5 || except == v6) {
														count = modAdd(count, (1 << m) - 7);
														nExEq++;
													} else {
														count = modAdd(count, (1 << m) - 8);
														nExNe++;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		// printf("n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", n, m, nEx0, nExEq, nExNe);
	} else if (n == 8) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							for (int v4 = 1; v4 < 1 << m; v4++) {
								if (v4 != v1 && v4 != v2 && v4 != v3) {
									for (int v5 = 1; v5 < 1 << m; v5++) {
										if (v5 != v1 && v5 != v2 && v5 != v3 && v5 != v4) {
											for (int v6 = 1; v6 < 1 << m; v6++) {
												if (v6 != v1 && v6 != v2 && v6 != v3 && v6 != v4 && v6 != v5) {
													for (int v7 = 1; v7 < 1 << m; v7++) {
														if (v7 != v1 && v7 != v2 && v7 != v3 && v7 != v4 && v7 != v5 && v7 != v6) {
															// should not be: v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 ^ v8 == 0
															int except = v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7;
															if (except == v1 || except == v2 || except == v3 || except == v4 || except == v5 || except == v6 || except == v7 || except == 0) {
																count = modAdd(count, (1 << m) - 8);
															} else {
																count = modAdd(count, (1 << m) - 9);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	} else if (n == 9) {
		assert(1 <= m && m <= 30);
		for (int v1 = 1; v1 < 1 << m; v1++) {
			for (int v2 = 1; v2 < 1 << m; v2++) {
				if (v2 != v1) {
					for (int v3 = 1; v3 < 1 << m; v3++) {
						if (v3 != v1 && v3 != v2) {
							for (int v4 = 1; v4 < 1 << m; v4++) {
								if (v4 != v1 && v4 != v2 && v4 != v3) {
									for (int v5 = 1; v5 < 1 << m; v5++) {
										if (v5 != v1 && v5 != v2 && v5 != v3 && v5 != v4) {
											for (int v6 = 1; v6 < 1 << m; v6++) {
												if (v6 != v1 && v6 != v2 && v6 != v3 && v6 != v4 && v6 != v5) {
													for (int v7 = 1; v7 < 1 << m; v7++) {
														if (v7 != v1 && v7 != v2 && v7 != v3 && v7 != v4 && v7 != v5 && v7 != v6) {
															for (int v8 = 1; v8 < 1 << m; v8++) {
																if (v8 != v1 && v8 != v2 && v8 != v3 && v8 != v4 && v8 != v5 && v8 != v6 && v8 != v7) {
																	// should not be: v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 ^ v8 ^ v9 == 0
																	int except = v1 ^ v2 ^ v3 ^ v4 ^ v5 ^ v6 ^ v7 ^ v8;
																	if (except == v1 || except == v2 || except == v3 || except == v4 || except == v5 || except == v6 || except == v7 || except == v8 || except == 0) {
																		count = modAdd(count, (1 << m) - 9);
																	} else {
																		count = modAdd(count, (1 << m) - 10);
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	} else {
		assert(false);
	}
	return count;
}

int solveFast(int n, int m) {
	if (m < 30 && n > (1 << m) - 1) {
		return 0; // the number of piles is greater than the amount of allowed numbers, return zero
	}
	if (n == 1) {
		return modSub(modPow(2, m), 1); // the number of values 1 <= x < 2^m
	} else if (n == 2) {
		int cnt1 = modSub(modPow(2, m), 1); // any number
		int cnt2 = modSub(modPow(2, m), 2); // any number except the first
		return modMul(cnt1, cnt2); // just multiply, xor == 0 mean that the numbers are equal but they are distinct
	/*
	} else if (n == 3) {
		int cnt1 = modSub(modPow(2, m), 1); // any number
		int cnt2 = modSub(modPow(2, m), 2); // any number except the first
		int cnt3 = modSub(modPow(2, m), 4); // any number except 1, 2 and (v1 ^ v2). (v1 ^ v2) != v1, (v1 ^ v2) != v2
		return modMul(cnt1, cnt2, cnt3);
	} else if (n == 4) {
		int cnt1 = modSub(modPow(2, m), 1); // any number
		int cnt2 = modSub(modPow(2, m), 2); // any number except the first
		int cnt3 = modSub(modPow(2, m), 3); // any number except the first and the second
		// 4th: if v1 ^ v2 ^ v3 == 0 -> v4 is any except v1, v2, v3 else this number is prohibited also. for n = 4 (v1 ^ v2 ^ v3) is not equal to v1, v2, v3
		int all3 = modMul(cnt1, cnt2, cnt3);
		int won3 = solveFast(3, m);
		int lost3 = modSub(all3, won3); // == cnt1 * cnt2
		int fromLost = modMul(lost3, modSub(modPow(2, m), 4));
		int fromWon = modMul(won3, modSub(modPow(2, m), 5));
		return modAdd(fromLost, fromWon);
	} else if (n == 5) {
		int cnt1 = modSub(modPow(2, m), 1);
		int cnt2 = modSub(modPow(2, m), 2);
		int cnt3 = modSub(modPow(2, m), 3);
		int cnt4 = modSub(modPow(2, m), 4);
		// v1 ^ v2 ^ v3 ^ v4 could be equal to v1 or v2 or v3 or v4.
		int nEx0 = solveFast(n - 2, m); // v1 ^ v2 ^ v3 ^ v4 == 0
		int nExEq = modMul(nEx0, n - 1); // v1 ^ v2 ^ v3 ^ v4 is equal to v1 or v2 or v3 or v4
		int all4 = modMul(cnt1, cnt2, cnt3, cnt4);
		int nExNe = modSub(all4, modAdd(nEx0, nExEq));
		// printf("fast n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", n, m, nEx0, nExEq, nExNe);
		return modAdd(modMul(modAdd(nEx0, nExEq), modSub(modPow(2, m), 5)), modMul(nExNe, modSub(modPow(2, m), 6)));
	} else if (n == 6) {
		int cnt1 = modSub(modPow(2, m), 1);
		int cnt2 = modSub(modPow(2, m), 2);
		int cnt3 = modSub(modPow(2, m), 3);
		int cnt4 = modSub(modPow(2, m), 4);
		int cnt5 = modSub(modPow(2, m), 5);
		// v1 ^ v2 ^ v3 ^ v4 ^ v5 == 0 and all are different
		int all5 = modMul(modMul(cnt1, cnt2), modMul(cnt3, cnt4, cnt5));
		int nEx0 = modSub(all5, solveFast(n - 1, m));
		int all4 = modMul(cnt1, cnt2, cnt3, cnt4);
		int lost4 = modSub(all4, solveFast(n - 2, m));
		int nExEq = modMul(lost4, modSub(modPow(2, m), 5), 5);
		int nExNe = modSub(all5, modAdd(nEx0, nExEq));
		// printf("fast n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", n, m, nEx0, nExEq, nExNe);
		return modAdd(modMul(modAdd(nEx0, nExEq), modSub(modPow(2, m), 6)), modMul(nExNe, modSub(modPow(2, m), 7)));
	} else if (n == 7) {
		int cnt1 = modSub(modPow(2, m), 1);
		int cnt2 = modSub(modPow(2, m), 2);
		int cnt3 = modSub(modPow(2, m), 3);
		int cnt4 = modSub(modPow(2, m), 4);
		int cnt5 = modSub(modPow(2, m), 5);
		int cnt6 = modSub(modPow(2, m), 6);
		int all6 = modMul(modMul(cnt1, cnt2, cnt3), modMul(cnt4, cnt5, cnt6));
		int nEx0 = modSub(all6, solveFast(n - 1, m));
		int all5 = modMul(modMul(cnt1, cnt2), modMul(cnt3, cnt4, cnt5));
		int lost5 = modSub(all5, solveFast(n - 2, m));
		int nExEq = modMul(lost5, modSub(modPow(2, m), 6), 6);
		int nExNe = modSub(all6, modAdd(nEx0, nExEq));
		printf("fast n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", n, m, nEx0, nExEq, nExNe);
		return modAdd(modMul(modAdd(nEx0, nExEq), modSub(modPow(2, m), 7)), modMul(nExNe, modSub(modPow(2, m), 8)));
	*/
	} else {
		int pow2m = modPow(2, m);
		std::vector<int> all(1 + n);
		all[0] = 1;
		for (int i = 1; i <= n; i++) {
			all[i] = modMul(all[i - 1], modSub(pow2m, i));
		}
		std::vector<int> win(1 + n);
		for (int i = 1; i <= 2; i++) {
			win[i] = solveFast(i, m);
		}
		std::vector<int> lost(1 + n);
		for (int i = 1; i <= 2; i++) {
			lost[i] = modSub(all[i], win[i]);
		}
		for (int i = 3; i <= n; i++) {
			int nEx0 = lost[i - 1];
			int nExEq = modMul(lost[i - 2], modSub(pow2m, i - 1), i - 1);
			int nExNe = modSub(win[i - 1], nExEq);
			// printf("fast n=%d m=%d nEx0=%d nExEq=%d nExNe=%d\n", i, m, nEx0, nExEq, nExNe);
			win[i] = modAdd(modMul(modAdd(nEx0, nExEq), modSub(pow2m, i)), modMul(nExNe, modSub(pow2m, i + 1)));
			lost[i] = modSub(all[i], win[i]);
		}
		return win.back();
   	}
}

void research() {
	for (int i = 0; i < 100; i++) {
		for (int j = 0; j < 100; j++) {
			found[i][j] = -1;
		}
	}
	{
		int n = 1;
		for (int m = 1; m <= 20; m++) { // ~1 min to 35
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[1][21] = 2097151;
	found[1][22] = 4194303;
	found[1][23] = 8388607;
	found[1][24] = 16777215;
	found[1][25] = 33554431;
	found[1][26] = 67108863;
	found[1][27] = 134217727;
	found[1][28] = 268435455;
	found[1][29] = 536870911;
	found[1][30] = 73741816;
	found[1][31] = 147483633;
	found[1][32] = 294967267;
	found[1][33] = 589934535;
	found[1][34] = 179869064;
	found[1][35] = 359738129;
	{
		int n = 2;
		for (int m = 1; m <= 10; m++) { // ~1 min to 17
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[2][11] = 4188162;
	found[2][12] = 16764930;
	found[2][13] = 67084290;
	found[2][14] = 268386306;
	found[2][15] = 73643515;
	found[2][16] = 294770662;
	found[2][17] = 179475851;
	{
		int n = 3;
		for (int m = 1; m <= 7; m++) { // ~1 min to 12
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[3][8] = 16322040;
	found[3][9] = 132389880;
	found[3][10] = 66416113;
	found[3][11] = 560603072;
	found[3][12] = 602093084;
	{
		int n = 4;
		for (int m = 1; m <= 5; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[4][6] = 14061600;
	found[4][7] = 246046752;
	found[4][8] = 113154052;
	{
		int n = 5;
		for (int m = 1; m <= 4; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[5][5] = 19764360;
	found[5][6] = 830337480;
	found[5][7] = 269703030;
	{
		int n = 6;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[6][4] = 3402000;
	found[6][5] = 513873360;
	{
		int n = 7;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[7][4] = 30240000;
	found[7][5] = 836678316;
	{
		int n = 8;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	found[8][4] = 241920000;
	{
		int n = 9;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlowest(n, m);
			found[n][m] = res;
			// printf("\tfound[%d][%d] = %d;\n", n, m, res);
		}
	}
	// now solveSlow
	for (int n = 1; n <= 2; n++) {
		for (int m = 1; m < 100; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				// printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	{
		int n = 3;
		for (int m = 1; m <= 11; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[3][13] = 286162677;
	found[3][14] = 167661508;
	found[3][15] = 856108576;
	found[3][16] = 910886972;
	{
		int n = 4;
		for (int m = 1; m <= 7; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[4][9] = 254058571;
	found[4][10] = 744434791;
	found[4][11] = 872671153;
	{
		int n = 5;
		for (int m = 1; m <= 5; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[5][8] = 450632976;
	{
		int n = 6;
		for (int m = 1; m <= 4; m++) { // !!! 4
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[6][6] = 159573504;
	found[6][7] = 903769436;
	{
		int n = 7;
		for (int m = 1; m <= 4; m++) { // !!! 4
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[7][6] = 891796472; // several minutes!
	{
		int n = 8;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	found[8][5] = 80279444; // couple of minutes
	{
		int n = 9;
		for (int m = 1; m <= 3; m++) {
			int res = solveSlow(n, m);
			if (found[n][m] == -1) {
				found[n][m] = res;
				printf("\tfound[%d][%d] = %d;\n", n, m, res);
			}
			if (res != found[n][m]) {
				printf("solveSlow != solveSlowest for n=%d m=%d: slowest=%d slow=%d\n", n, m, found[n][m], res);
			}
			assert(res == found[n][m]);
		}
	}
	// fast!
	int nEq = 0;
	for (int n = 1; n < 100; n++) {
		for (int m = 1; m < 100; m++) {
			if (found[n][m] != -1) {
				int res = solveFast(n, m);
				nEq++;
				if (res != found[n][m]) {
					printf("solveFast != solveSlow for n=%d m=%d: slow=%d fast=%d\n", n, m, found[n][m], res);
				}
				assert(res == found[n][m]);
			}
		}
	}
	fprintf(stderr, "fast=slow %d times\n", nEq);
	// std::exit(0);
}

int main() {
	research();
	int n, m;
	scanf("%d %d", &n, &m);
	printf("%d", solveFast(n, m));
	return 0;
}

```


```python
import sys
n,m = map(int,sys.stdin.readline().split())

p = 1000000007

def pow_mod(x, y, z):
    number = 1
    while y:
        if y & 1:
            number = number * x % z
        y >>= 1
        x = x * x % z
    return number

S = pow_mod(2,m,p)-1 % p
A1 = 0
A2 = 0
A3 = S
W = S

z1 = pow_mod(2,m,p)
x = z1-1
for i in range(2,n+1):
    x -= 1
    A3 = (i * (S-W) * x)%p
    S = (S*x)%p
    W = (S-A1)
    A1 = (W - A3)
    #A2 = (S-W)
print W%p
```
