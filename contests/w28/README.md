
### Comments after WoC


![rank](https://cloud.githubusercontent.com/assets/5623445/21991503/e5344164-dbe0-11e6-8974-4a8492b8994b.PNG)

나부터 그렇게 최고의 좋은 성적으로 학창 시절을 보내지 못했기에..나 스스로는 등수에 큰 의미를 두는 성향은 아니라고 믿는 편이다. 하지만 가끔 어떠한 경쟁의 등수 분포를 관찰하는 것은 그 문화를 이해하는 많은 이야기가 있다고 생각한다. 

이제 다섯 번째 참석하는 HackerRank WoC(Week of Code) 대회에서 28주차 대회를 마치고 이번 대회의 통계를 몇 가지 관점에서 바라보았다. 나는 5번의 대회를 가볍게(?) 참가하면서 - 여기서 가볍게 참가한다는 것은 7일차 문제 중 5일 이후부터는 능력이 부족해서 더 이상 풀 생각조차 하지 않는다는 것이다. - 대회가 마칠 때마다 대략적인 통계를 2-30분 가량 보고 혼자 여러 가지 생각을 하였는데 이번 대회에서는 그 느낌을 조금 적어놓고 싶어서 조금 진지하게 통계를 기록하였다. 이 통계는 매번 대회마다 차이가 있으나 내가 말하고 싶어하는 것은 매번 반복되어 보여지는 어떤 이야기를 하고 싶다는 것을 미리 밝힌다.

제일 먼저 눈에 들어오는 숫자는 총 참가자 10,451 명 중 (평상시 6 -7 천명보다 많았다) 인도 개발자들이 거의 60%에 달할 만큼 많았고, 의의로 중국인 참가자가 많지 않았다는 것도  의외였다. 하지만 미국과 북미에서 참여하는 많은 사람들은 주로 인도나 중국과 같은 곳에서 온 이민 가정의 자녀들이거나 이러한 국가들에서 온 유학생들이 상당수 포함될 수 있으므로 중국인 수가 90명 밖에 되지 않는 것은 허수일 가능성이 높아 보인다. 

첫째 상위 20위 안에 드는 국가별 분포를 보면 동/서 유럽을 합쳤을 때 유럽인들이 50% 를, 그리고 일본/중국을 포함한 아시아 국가와 중남미를 포함한 미주 대륙이 나머지 50%를 차지 하고 있다. 

좌측 도표를 보면 인도인 개발자 5천 8백명이나 참가하였음에도 불구하고 상위 20위 안은 고사하고.. 100위안에도 한 명도 포함되지 못하였다(눈으로 2번 재확인하였다) . 나는 이 흐름은 현재 전 세계 IT를 선도하는 수많은 인도인 개발자들의 존재와 이에 따른 명암을 잘 보여준다고 믿는다. 물론 현재 모든 동영상의 구현에 들어가는 핵심 엔진인 DCT(Discrete Cosine Transformation) 알고리듬을 최초로 개발한 사람은 인도인 출신 Nasir Ahmed 교수이다. 이와 같은 창의적인 많은 훌륭한 과학자가 있다는 것을 의심하지는 않지만 현재 북미의 IT 아웃소싱의 대명사인 수많은 인도인 개발자들의 존재는 소문으로만 존재하는 소프트웨어 품질 저하의 가장 큰 주범으로 원인 제공을 할 가능성도 있다는 것이다. 

(중국/한국과 같이 북미에 많이 진출하지 않고) 자국 내에서 육성되고 활동을 하는 일본인 개발자들의 현황이 눈에 들어오지 않을 수 없다. 20위 도표에서 (온라인 상에서는 많은 개발자들에게 이미 유명한) 일본인 위(Uwi)를 포함하여 상위 입상자만 3명이고 전체 참가자 52명 중 20%에 해당하는 10명 가량이 상위 100 위 안에 들었다. 이 통계는 중국 심지어는 러시아 국가와 같은 나라 참가자에 비해서도 매우 주목할 만한 숫자인데 참가자 6천명인 인도인이 100위에 한 명도 포함되지 않았다는 것을 염두에 두면 더욱 눈에 띄인다. 일본인 참가자 중에는 여성 개발자와 고등학생도 1-2명 포함되어 있어서 개발자들에 대한 저변 확대가 매우 광범히 하다는 인상을 받게 한다. 

국가별 참가자 인원 수를 고려할 때 한국,일본과 중국인, 러시아 인들은 어느 정도 경험과 수준이 있거나 실제 해당 업무를 하고  있는 전문 개발자(최소한 대학원 생 이상)들이 대회에 참가하고 있다는 생각을 하게 되고 북한의 유일한 참가자 한 명 (RyongNamSan)은 37위로 상당히 높은 순위에 있는 편인데, 국가의 폐쇄성을 고려해볼 때 뚜렷한 재능을 보여주는 개발자로서 국가적인 배려로 참가를 할 수 있지 않았나 생각한다. 

문제의 난이도에 따른 통계는 해당 문제 별로 다시 국가별 분포를 보아야 하기 때문에 그에 대한 추가적인 조사를 하지는 않았다. 그리고 그들이 개발자들로서 구체적인 어떠한 일들을 하는지에 대한 통계 조사는 이 대회 사이트에서 제공하는 정보로는 수집이 불가능하다. 단지 (온라인 상에서 이들과 메일로 주고 받거나 다른 사이트를 검색하면서 알게 된 경험을 바탕으로 볼 때) 최고 상위권 입상자인 일본인 ‘위’는 다른 각종 대회에도 항상 출전하는 이른바 ‘꾼’에 해당하고 2위인 _mfv_ 러시아인 역시 이런 코딩 대회 참가자들을 교육하는 일을 하고 있다는 것을 보면 이러한 대회에서 최고 상위 입상자들은 단순한 개발자를 넘어서서 거의 직업적으로 이러한 코딩 대회를 참가하는 일을 직/간접적으로 하고 있지 않을까 하는 의구심을 들게 한다.

한 예로 한국의 커다란 기술 회사인 삼성과 LG에서 참석하는 개발자들을 보면 삼성에서 참가하는 개발자들의 수는 거의 제로에 불과하다. 그 회사가 보유하는 수준 높은 개발자들의 수가 부족하다기 보다는 업무에 혹사당하거나 회사 내의 불필요한 잔업이나 보안 등의 이유로 업무 이외의 이러한 활동들이 원천적으로 봉쇄되었기 때문일 확률이 크다.

내가 지금까지 확인할 수 있었던 삼성 소속의 개발자는 몽고에서 온 해외 개발자(dulguunbatmunkh) 라는 사람인데 이 사람은 삼성에서 어느 정도 이 대회와 유사한 성격의 업무를 하고 있으며 해외에서 온 글로벌 직원이라는 역(?) 특혜의 결과로 다른 한국인 직원보다 업무 이후의 자유 시간이 보다 가능할 수 있다고 판단되어 진다. 물론 모두 퇴근 후에 이러한 활동을 하는 것은 아니기 때문에 업무 후에 이러한 대회에 참석을 한다면 이 개발자의 노력이 칭찬을 받아야 하는 것은 당연하지만 다른 한국인 개발자들에게 공평한 기회가 주어졌다고 보기에는 더 많은 검토가 필요할 수 있다.

개인적인 이번 조사의 한계는 (1) 너무나 특정한 한 시점에 일회성 데이터를 가지고 통계를 구했다는 것과 무엇보다 (2) 이 사이트에 참석하는 개발자들의 수가 한 국가나 회사들의 일정한 비율 분포를 대표하고 있다는 전제를 할 수 없다는 점이다. 


그럼에도 불구하고, 현재 일부에서 말하고 있는 “4차 산업 혁명” (나는 조금은 냉소적이기는 하다) 의 가장 중요한 지식 기반인 “코딩교육”에 대한 이야기를 할 때, 현재 활발하게 운영되는 한 “코딩 대회”의 국가/지역별 실제의 통계를 가지고 각 국가별 개발자들의 현황과 그 내용을 바라보는 것과 이야기를 할 때 최소한의 구체적 증거를 제시하는 면에서 작은 의미가 없지 않다고 보아야 할 것이다.

- 2017년 1월 16일 작성

---



###  나의 메일


4일차 문제를 풀면서..개인적으로 한 문제 해결을 위해 DFS(Depth First Search) 알고리듬을 그렇게 오랜 시간 고민해보기는 처음이었습니다. (요즘은 회사 면접 때문에 다시 자바로 연습하기에..) 첫날은 자바로 짰다가 쉽게 Set에 넣어서 원소 전체의 갯수를 세고 답을 구하는 방법으로 하였더니...별의 별 방법을 써도 통과를 못하더군요.. 그래서 결국 2차원 배열에 넣어서 DFS 방법으로 고민을 다시 하기 시작했습니다. (부분 점수도 못 받았지만) 이렇게 많은 것을 스스로 배운 프로그램 과제는 처음이었습니다. 앞으로 응용할 수 있는 여러가지들을 정말로 많이 느꼈습니다..
대회 내내..정말 뼈저리게 느낀 것은 “꼴찌를 해도 내 힘으로 끝까지 가봐야 만 배울 수 있는 부분이 있다”는 것이었습니다.  5일차 6일차 문제도 조금 능력이 되면 재미있겠다 싶었지만..일단 이번 대회에서 만점을 받지 못한 3/4일 차 문제를 다음 달까지 몇 번이고 Review를 해야겠다 싶었습니다.

---

###  노영만(님) 답변 메일
1)
4일차 문제는 dfs()로 알고리즘을 수립하고 memoization으로 성능을 높이면 됩니다.
물론 그러고도 최적화할 부분들이 꽤 있지만 일단은 이 조합이면 어느정도 점수를 받을 수 있습니다.
이미 아실지 모르겠지만 memoization은 dynamic programming의 한 분류로(엄격히 다른 기술로 보는 사람도 있습니다만)
DFS 방식으로 구현한 알고리즘에서 반복적인 계산이 많을 때 이전 계산을 cache로 저장해 놓았다가
다음과 같은 계산을 할 때 중복 계산을 줄이는 방법입니다.
메모이제이션은 아래와 같은 code pattern을 가집니다.

```
                 hash_table  M;   // 배열, hash table 등 적당한 자료 구조를 사용하면 됩니다.

                 int dfs(int param) {
                       if (M.find(param))
                           return M[param];               // 이전 값 확인 후 있으면 반환

                       // .....  실제 계산

                       return M[param] = result;     // 결과를 cache에 저장함과 동시에 return
                 }                
```
자세한 내용은 memoization은 구종만님 책 210 페이지에도 나와있습니다.

2)
이전에 제가 말씀드린건 5일차 문제네요. 헷갈렸어요.
4일차는 union-find라는 자료구조가 유용합니다. Disjoint set이라고도 해요.
구종만님 책에도 있어요.


